#!/bin/bash
#
#  ccfind - tool for finding circular complete sequences by detecting terminal redundancy of each sequence
#
#    Copyright: 2017 (C) Yosuke Nishimura (yosuke@kuicr.kyoto-u.ac.jp)
#    License: MIT license
#

PROGNAME=$(basename $0)
VERSION="1.2.0"
PROGNAMEc="[35m$PROGNAME[0m"
Errmsg="[31m[error][0m"
Sccmsg="[32m[success][0m"
Moddate="2018-07-17"
incmd="$0 $*"


# {{{ usage
read -r -d '' usage <<EOF
[35m### $PROGNAME ver $VERSION ($Moddate) ###

[32m[description][0m
$PROGNAME is tool to find circular complete sequence by detecting terminal redundancy.

$PROGNAME is originally designed to find circular complete contigs generated by the SPAdes assembler. 
$PROGNAME can be used for any contig/genome, but cutoff values (see below) should be carefully considered.

[32m[dependencies][0m
- ssearch        -- included in FASTA program
                    (available here: http://fasta.bioch.virginia.edu/fasta_www2/fasta_list2.shtml)
- blastn         -- included in the BLAST+ program;
                    (available here: https://blast.ncbi.nlm.nih.gov/Blast.cgi?PAGE_TYPE=BlastDocs&DOC_TYPE=Download)
- ruby (ver >=2.0) 

[32m[usage][0m
$ $PROGNAME <input fasta> <output dir> [options]

- <output dir> should not exist.

[32m[options][0m
  (general)
    -h, --help
    -v, --version

  (cutoff values)
    -L, --terminal-fragment-size  [int] (default: 500) -- This should be longer than estimated terminal redundancy length. If input length is less than 2 x (this value), the sequence will be ignored and listed in "result/01.skipped.list".
    -i, --min-percent-identity    [int] (default: 94)
    -l, --min-aligned-length      [int] (default: 50)

  (use GNU parallel)
    --ncpus        [int]    -- number of jobs in parallel	

  (for icr user)            -- for computation in the ICR supercomputer system
    --queue        [JP1]    -- queue for computation

[32m[output files][0m
result/05.circ.detected.out -- list of sequence with terminal redundancy.
result/05.circ.fasta        -- fasta file of sequences with terminal redundancy.
result/05.circ.noTR.fasta   -- fasta file of sequences with terminal redundancy, but the detected terminal redundnacy at the end of sequence is removed.
EOF
# }}} usage


# {{{ parse options
for OPT in "$@"
do
	case "$OPT" in
		'-h'|'--help' )
			echo "$usage"
			exit 1
			;;
		'-v'|'--version' )
			echo $VERSION
			exit 1
			;;
		'-i'|'--min-percent-identity' )
			if [[ -z "$2" ]] || [[ "$2" =~ ^-+ ]] ; then
				echo "$PROGNAME: option requires an argument -- $1" 1>&2
				exit 1
			fi
			idt="$2"
			shift 2
			;;
		'-l'|'--min-aligned-length' )
			if [[ -z "$2" ]] || [[ "$2" =~ ^-+ ]] ; then
				echo "$PROGNAME: option requires an argument -- $1" 1>&2
				exit 1
			fi
			len="$2"
			shift 2
			;;
		'-L'|'--terminal-fragment-size' )
			if [[ -z "$2" ]] || [[ "$2" =~ ^-+ ]] ; then
				echo "$PROGNAME: option requires an argument -- $1" 1>&2
				exit 1
			fi
			size="$2"
			shift 2
			;;
		'--queue' )
			if [[ -z "$2" ]] || [[ "$2" =~ ^-+ ]] ; then
				echo "$Errmsg option requires an argument -- $1" 1>&2
				exit 1
			fi
			queue="$2"
			shift 2
			;;
		'--ncpus' )
			if [[ -z "$2" ]] || [[ "$2" =~ ^-+ ]] ; then
				echo "$Errmsg option requires an argument -- $1" 1>&2
				exit 1
			fi
			ncpus="$2"
			shift 2
			;;
		'--wtime' )
			if [[ -z "$2" ]] || [[ "$2" =~ ^-+ ]] ; then
				echo "$Errmsg option requires an argument -- $1" 1>&2
				exit 1
			fi
			wtime="$2"
			shift 2
			;;
		'--'|'-' )
			shift 1
			params+=( "$@" )
			break
			;;
		-*)
			echo "$PROGNAME: illegal option -- '$(echo $1 | sed 's/^-*//')'" 1>&2
			exit 1
			;;
		*)
			if [[ ! -z "$1" ]] && [[ ! "$1" =~ ^-+ ]] ; then
				#params=( ${params[@]} "$1" )
				params+=( "$1" )
				shift 1
			fi
			;;
	esac
done
if [ -z $params ] || [ ${#params[@]} -lt 2 ] ; then
	echo "[error] need 2 arguments" 1>&2
	echo 
	echo "$usage" 1>&2
	exit 1
elif ! [ -f "${params[0]}" ] ; then
	echo "[error] first argument should be a fasta file." 1>&2
	echo 
	echo "$usage" 1>&2
	exit 1
elif [ -e "${params[1]}" ] ; then
	echo "[error] output directory is already exist." 1>&2
	echo 
	echo "$usage" 1>&2
	exit 1
fi
# }}} parse options


# {{{ check dependencies
### check availablity of ssearch36
command -v ssearch36 >/dev/null 2>&1 || { echo >&2 "ssearch36 is required but not available.  Aborting."; exit 1; }

### check availablity of blastn
command -v blastn >/dev/null 2>&1 || { echo >&2 "$Errmsg blastn (in BLAST+ package) is required but not available.  Aborting."; exit 1; }
command -v makeblastdb >/dev/null 2>&1 || { echo >&2 "$Errmsg makeblastdb (in BLAST+ package) is required but not available.  Aborting."; exit 1; }

### check ruby version
ST=`ruby -e 'print RUBY_VERSION.to_f >= 2.0 ? 0 : 1'`
if [ $ST -ne 0 ]; then 
	echo >&2 "ruby (version >=2.0) is required.  Aborting."; exit 1;
fi

### check availablity of GNU parallel
if [ -n $ncpus ]; then 
	command -v parallel >/dev/null 2>&1 || { echo >&2 "$Errmsg GNU parallel is required but not available.  Aborting."; exit 1; }
fi
# }}} check dependencies


# {{{ assign variables 
### parse args and default params
fin=${params[0]}
dir=${params[1]}
idt="${idt:-94}"
len="${len:-50}"
size="${size:-500}"
queue="${queue}"
nthread="${nthread:-1}"
wtime="${wtime:-24:00:00}"

### rakefile and log directory
pushd `dirname $0` > /dev/null
scrdir=`pwd -P`
popd > /dev/null
jobname=`basename $0`
rakefile=$scrdir/$jobname.rake
logdir=$dir/log
# }}} assign variables 


# {{{ after run function
function after_run(){
  endTime=$(LC_ALL=C date +"%Y-%m-%d %H:%M:%S %z")

  if [[ $1 -gt 0 ]] ; then
    echo "$Errmsg run failed: $endTime" > "$logdir/$startTime.$jobname.error"
    echo "$Errmsg process is killed: $endTime" |tee -a "$logdir/$jobname.log"
    exit 1
  else
    echo "$Sccmsg run finished: $endTime" > "$logdir/$startTime.$jobname.success"
  fi
}
### }}} after run function


# {{{ input command
read -r -d '' incmdlog <<EOF

[1;32m===== command line[0m

$ $incmd

[1;32m===== log file[0m

$logdir/$jobname.log

[1;32m===== check version: $PROGNAME[0m

$VERSION

EOF
# }}} input command


### main
mkdir -p $logdir
startTime=$(LC_ALL=C date +"%Y-%m-%d %H:%M:%S")

## write input command
echo "$incmdlog" |tee -a $logdir/$jobname.log

## trap Ctrl-C etc...
trap 'after_run 1' 1 2 3 9 15

### run
rake -f $rakefile dir="$dir" fin="$fin" size="$size" len="$len" idt="$idt" queue="$queue" ncpus="$ncpus" wtime="$wtime" 2>&1 |tee -a $logdir/$jobname.log
st=$(( ${PIPESTATUS[0]} + ${PIPESTATUS[1]} ))
after_run $ST
